a <- df_pt %>% filter(V1 < 268.95)
a <- df_pt > filter(V1 < 268.95)
PT[,1] < 268.95
count(PT[,1])
nrow(PT[,1])
lenght(PT[,1])
length(PT[,1])
lenght(PT[,1] < 268.95)
length(PT[,1] < 268.95)
#Probabilidad de que el precio final sea menor a 268.95
df_pt <- data.frame(PT)
df_pt[df_pt$1 <268.95]
#Probabilidad de que el precio final sea menor a 268.95
df_pt <- data.frame(PT)
df_pt
df_pt <268.95
df_pt[df_pt <268.95]
length(df_pt[df_pt <268.95])
length(df_pt[df_pt <268.95]) / length(PT[,1])
df_p0at <- data.frame(P0aT)
length(df_pt[df_pt > 364.79]) / length(PT[,1])
df_p0at <- data.frame(P0aT)
View(df_p0at)
View(df_p0at)
df_p0at
ncol(df_p0at)
length(P0aT[,ncol(P0aT)])
length(df_p0aT[df_p0at[,ncol(P0aT)] <268.95]) / length(P0aT[,ncol(P0aT)])
length(df_p0aT[df_p0at[,ncol(df_p0at)] <268.95]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at[,ncol(df_p0at)] <268.95]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at$X188 <268.95]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at$X187 <268.95]) / length(P0aT[,ncol(P0aT)])
df_p0at$X187
df_p0at$X188
df_p0at$X188 <268.95
df_p0at[df_p0at$X188 <268.95]
df_p0at[ ,df_p0at$X188 <268.95
length(df_p0at[ ,df_p0at$X188 <268.95]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at$X188 < 268.95, ]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at$X188 > 364.79, ]) / length(P0aT[,ncol(P0aT)])
length(df_p0at[df_p0at$X188 < 268.95, ])
df_p0at[df_p0at$X188 < 268.95, ]
df_p0at[df_p0at$X188 < 268.95, X188]
df_p0at[df_p0at$X188 < 268.95, "X188"]
length(df_p0at[df_p0at$X188 < 268.95, "X188"]) / length(P0aT[,ncol(P0aT)]) # 0.094
length(df_p0at[df_p0at$X188 > 364.79, "X188" ]) / length(P0aT[,ncol(P0aT)]) #0.094
simpson.compuesto = function(a, b, n){
if((n %% 2) == 0){
#Paso 1
h = (b-a)/n
#Paso 2
xio = fn(a) + fn(b)
xi1 = 0 #Suma impar
xi2 = 0 #Suma par
#Paso 3
for (i in 1:(n-1)) {
#Paso 4
x = a + i*h
#Paso 5
if((i %% 2) == 0){
xi2 = xi2 + fn(x)
}else{
xi1 = xi1 + fn(x)
}
}
#Paso 6
val = h*(xio + 2*xi2 + 4*xi1)/3
return(val)
}
else return("n debe ser par")
}
alpha = 3
beta = 1
simpson.compuesto = function(a, b, n, fn){
if((n %% 2) == 0){
#Paso 1
h = (b-a)/n
#Paso 2
xio = fn(a) + fn(b)
xi1 = 0 #Suma impar
xi2 = 0 #Suma par
#Paso 3
for (i in 1:(n-1)) {
#Paso 4
x = a + i*h
#Paso 5
if((i %% 2) == 0){
xi2 = xi2 + fn(x)
}else{
xi1 = xi1 + fn(x)
}
}
#Paso 6
val = h*(xio + 2*xi2 + 4*xi1)/3
return(val)
}
else return("n debe ser par")
}
gamma = function(x, z){
val = x^(z-1) * exp(-x)
return(val)
}
gamma_alpha+beta = simpson.compuesto(0,10000, 1000, fn = expression(x^(4-1) * exp(-x)))
simpson.compuesto = function(a, b, n, fn){
if((n %% 2) == 0){
#Paso 1
h = (b-a)/n
#Paso 2
xio = fn(a) + fn(b)
xi1 = 0 #Suma impar
xi2 = 0 #Suma par
#Paso 3
for (i in 1:(n-1)) {
#Paso 4
x = a + i*h
#Paso 5
if((i %% 2) == 0){
xi2 = xi2 + fn(x)
}else{
xi1 = xi1 + fn(x)
}
}
#Paso 6
val = h*(xio + 2*xi2 + 4*xi1)/3
return(val)
}
else return("n debe ser par")
}
gamma_alpha+beta = simpson.compuesto(0,10000, 1000, fn = expression(x^(4-1) * exp(-x)))
gamma_alpha = simpson.compuesto(0,10000, 1000, fn = expression(x^(3-1) * exp(-x)))
gamma_beta = simpson.compuesto(0,10000, 1000, fn = expression(x^(1-1) * exp(-x)))
gamma_alpha+beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression(x^(4-1) * exp(-x)))
simpson.compuesto = function(a, b, n, fn){
if((n %% 2) == 0){
#Paso 1
h = (b-a)/n
#Paso 2
xio = fn(a) + fn(b)
xi1 = 0 #Suma impar
xi2 = 0 #Suma par
#Paso 3
for (i in 1:(n-1)) {
#Paso 4
x = a + i*h
#Paso 5
if((i %% 2) == 0){
xi2 = xi2 + fn(x)
}else{
xi1 = xi1 + fn(x)
}
}
#Paso 6
val = h*(xio + 2*xi2 + 4*xi1)/3
return(val)
}
else return("n debe ser par")
}
gamma_alpha+beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression(x^(4-1) * exp(-x)))
gamma_alpha+beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression( x^3 * exp(-x)))
gamma_alpha = simpson.compuesto(a = 0, b = 10000, n = 1000, fn = expression( x^2 * exp(-x)))
gamma_beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression( x^0 * exp(-x)))
simpson.compuesto = function(a, b, n, fn){
if((n %% 2) == 0){
#Paso 1
h = (b-a)/n
#Paso 2
xio = fn(a) + fn(b)
xi1 = 0 #Suma impar
xi2 = 0 #Suma par
#Paso 3
for (i in 1:(n-1)) {
#Paso 4
x = a + i*h
#Paso 5
if((i %% 2) == 0){
xi2 = xi2 + fn(x)
}else{
xi1 = xi1 + fn(x)
}
}
#Paso 6
val = h*(xio + 2*xi2 + 4*xi1)/3
return(val)
}
else return("n debe ser par")
}
gamma = function(x, z){
val = x^(z-1) * exp(-x)
return(val)
}
gamma_alpha+beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression( x^3 * exp(-x)))
gamma_alpha = simpson.compuesto(a = 0, b = 10000, n = 1000, fn = expression( x^2 * exp(-x)))
gamma_beta = simpson.compuesto(a = 0,b = 10000, n = 1000, fn = expression( x^0 * exp(-x)))
gamma_alpha_beta = simpson.compuesto(a = 0,b = 1000, n = 1000, fn = expression( x^3 * exp(-x)))
Esp_Y -< simpson.compuesto(a= 0 , b= 1 , n = 100 , fn = expression(x * (gamma_alpha_beta / (gamma_alpha + gamma_beta) * x^ 2 * (1-x) ^ 0))
Esp_Y <- simpson.compuesto(a= 0 , b= 1 , n = 100 , fn = expression(x * (gamma_alpha_beta / (gamma_alpha + gamma_beta) * x^ 2 * (1-x) ^ 0))
Esp_y
10^-10
Metodo_Trapecio(a,b)
#### EJERCICIO 1 ####
# 1.1 ----
Metodo_Trapecio <- function(a, b){
h = (b - a)
xo = a
x1 = b
result = (h/2)*(fn(xo) + fn(x1))
return(result)
}
Metodo_Simpson <- function(a,b){
h = (b - a)/2
xo = a
x2 = b
x1 = (xo + x2)/2
#x1a = a + (b -a)/2
result = (h/3)*(fn(xo) + 4*fn(x1) + fn(x2))
return(result)
}
Metodo_TresOctavos_Simpson <- function(a,b){
h = (b - a)/3
xo = a
x3 = b
x1 = xo + h
x2 = xo + 2*h
result = ((3/8)*h)*(fn(xo) + 3*fn(x1) + 3*fn(x2) + fn(x3))
return(result)
}
#Parametros
alpha = 4.36
theeta = 2.52
fn <- function (x){
val <- (alpha^2 *(x/theeta)^alpha)/ (x*(1+(x/theeta)^alpha)^(alpha+1))
return(val)
}
#Probabilidad de que Y este entre 1.15 y 4.99
a = 1.15
b = 4.99
#Con el metodo del trapecio, utilizo los nodos
print("Nodos utilizados: y0,y1")
Metodo_Trapecio(a,b)
#Con el metodo de Simpson}
print("Nodos utilizados: y0, y1, y2")
Probabilidad_Con_Simpson = Metodo_Simpson(a,b)
Probabilidad_Con_Simpson
#Con el metodo de Tres Octavos de Simpson
print("Nodos utilizados: y0,y1,y2,y3")
Probabilidad_Con_Simpson3OCtavos = Metodo_TresOctavos_Simpson(a,b)
Probabilidad_Con_Simpson3OCtavos
#1.2 ----
trapecio.compuesto = function(a, b, n){
h = (b-a)/n
xio = fn(a) + fn(b)
xi = 0
for (i in 1:(n-1)) {
x = a + i*h
xi = xi + fn(x)
}
val = h*(xio + 2*xi)/2
return(val)
}
n=17
#Probabilidad
Probabilidad_Con_TrapecioCompuesto = trapecio.compuesto(a,b,n)
Probabilidad_Con_TrapecioCompuesto
#COTA DEL ERROR
alim<-1.15   #cargar límite inferior intervalo
blim<-4.99  #cargar límite superior intervalo
d1tc<-D(expression((alpha^2 *(x/theeta)^alpha)/ (x*(1+(x/theeta)^alpha)^(alpha+1))),"x") #cargar función que desea derivar
d2tc<-D(d1tc,"x")
d2tc
derivadatc2<-function(x){
f<-alpha^2 * ((x/theeta)^((alpha - 1) - 1) * ((alpha - 1) * (1/theeta)) *
(alpha * (1/theeta)))/(x * (1 + (x/theeta)^alpha)^(alpha +
1)) - alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta))) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))))/(x * (1 + (x/theeta)^alpha)^(alpha +
1))^2 - ((alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta))) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta)))))) + (alpha^2 * (x/theeta)^alpha) * ((1 +
(x/theeta)^alpha)^((alpha + 1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha -
1) * (alpha * (1/theeta)))) + (((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))) + x * ((1 + (x/theeta)^alpha)^(((alpha + 1) -
1) - 1) * (((alpha + 1) - 1) * ((x/theeta)^(alpha - 1) *
(alpha * (1/theeta)))) * ((alpha + 1) * ((x/theeta)^(alpha -
1) * (alpha * (1/theeta)))) + (1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^((alpha - 1) - 1) *
((alpha - 1) * (1/theeta)) * (alpha * (1/theeta))))))))/(x *
(1 + (x/theeta)^alpha)^(alpha + 1))^2 - (alpha^2 * (x/theeta)^alpha) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta)))))) * (2 * (((1 + (x/theeta)^alpha)^(alpha +
1) + x * ((1 + (x/theeta)^alpha)^((alpha + 1) - 1) * ((alpha +
1) * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta)))))) *
(x * (1 + (x/theeta)^alpha)^(alpha + 1))))/((x * (1 + (x/theeta)^alpha)^(alpha +
1))^2)^2)
return(f)
}
optimotc<-optimize(derivadatc2,c(alim,blim),maximum = T)
opttc<-abs(optimotc$objective)
opttc
error<-((blim-alim)/12)*(((blim-alim)/n)^2)*opttc
error
#RELACION CON EL PUNTO 1.1
Probabilidad_Con_TrapecioCompuesto + error
Probabilidad_Con_Trapecio
Probabilidad_Con_Trapecio = Metodo_Trapecio(a,b)
Probabilidad_Con_Trapecio
Probabilidad_Con_Trapecio
Probabilidad_Con_TrapecioCompuesto + error - Probabilidad_Con_Trapecio
Esperanza_y = trapecio.compuesto(a,b,n)
Esperanza_y
n= 174
Esperanza_y = trapecio.compuesto(a,b,n)
Esperanza_y
#COTA DEL ERROR
d1tc<-D(expression("FUNCION EXPRESADA"),"x") #cargar función que desea derivar
#COTA DEL ERROR
d1tc<-D(expression(x * ((alpha^2 *(x/theeta)^alpha)/ (x*(1+(x/theeta)^alpha)^(alpha+1)))),"x") #cargar función que desea derivar
d2tc<-D(d1tc,"x")
d2tc
derivadatc2<-function(x){
f<-alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta)))/(x *
(1 + (x/theeta)^alpha)^(alpha + 1)) - (alpha^2 * (x/theeta)^alpha) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))))/(x * (1 + (x/theeta)^alpha)^(alpha +
1))^2 + ((alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta)))/(x *
(1 + (x/theeta)^alpha)^(alpha + 1)) - (alpha^2 * (x/theeta)^alpha) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))))/(x * (1 + (x/theeta)^alpha)^(alpha +
1))^2) + x * (alpha^2 * ((x/theeta)^((alpha - 1) - 1) * ((alpha -
1) * (1/theeta)) * (alpha * (1/theeta)))/(x * (1 + (x/theeta)^alpha)^(alpha +
1)) - alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta))) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))))/(x * (1 + (x/theeta)^alpha)^(alpha +
1))^2 - ((alpha^2 * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta))) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta)))))) + (alpha^2 * (x/theeta)^alpha) * ((1 +
(x/theeta)^alpha)^((alpha + 1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha -
1) * (alpha * (1/theeta)))) + (((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta))))) + x * ((1 + (x/theeta)^alpha)^(((alpha + 1) -
1) - 1) * (((alpha + 1) - 1) * ((x/theeta)^(alpha - 1) *
(alpha * (1/theeta)))) * ((alpha + 1) * ((x/theeta)^(alpha -
1) * (alpha * (1/theeta)))) + (1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^((alpha - 1) - 1) *
((alpha - 1) * (1/theeta)) * (alpha * (1/theeta))))))))/(x *
(1 + (x/theeta)^alpha)^(alpha + 1))^2 - (alpha^2 * (x/theeta)^alpha) *
((1 + (x/theeta)^alpha)^(alpha + 1) + x * ((1 + (x/theeta)^alpha)^((alpha +
1) - 1) * ((alpha + 1) * ((x/theeta)^(alpha - 1) * (alpha *
(1/theeta)))))) * (2 * (((1 + (x/theeta)^alpha)^(alpha +
1) + x * ((1 + (x/theeta)^alpha)^((alpha + 1) - 1) * ((alpha +
1) * ((x/theeta)^(alpha - 1) * (alpha * (1/theeta)))))) *
(x * (1 + (x/theeta)^alpha)^(alpha + 1))))/((x * (1 + (x/theeta)^alpha)^(alpha +
1))^2)^2)))
return(f)
}
optimotc<-optimize(derivadatc2,c(alim,blim),maximum = T)
opttc<-abs(optimotc$objective)
opttc
error<-((b-a)/12)*(((b-a)/n)^2)*opttc
error
#1.4----
#Calculamos E(Y^2)
fn <- function (x){
val <- x^2 * ((alpha^2 *(x/theeta)^alpha)/ (x*(1+(x/theeta)^alpha)^(alpha+1)))
return(val)
}
Esperanza_y2 = trapecio.compuesto(a,b,n)
Esperanza_y2
Varianza_Y = Esperanza_y2 - Esperanza_y^2
Varianza_Y
#### EJERCICIO 2 #####
r <- seq(0,0.12, by=0.01)
r
Pr <- c(115.3371, 109.7031,104.8099,100.0653,95.3516,91.1998,87.2676,83.5825,79.9116,76.8435,73.9473,70.0320,67.7022)
Pr
derivada3ptos_Progresiva_Endpoint<-function(x, y, xindice){
n = length(y)
yprima = c(rep(NA,n))
h = diff(x)[1]
if(missing(xindice)){
for (i in 1:(n - 2)) {
yprima[i] = (-3*y[i] + 4*y[i+1] - y[i+2])/(2*h)
}
tabla = cbind.data.frame(x, y, yprima)
return(tabla)
}
else{
if(xindice == n || xindice == n-1){
return("Este valor no se puede calcular")
}
else{
yprima[xindice] = (-3*y[xindice] + 4*y[xindice+1] - y[xindice+2])/(2*h)
return(yprima[xindice])
}
}
}
Derivada_0.04 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.04)
Derivada_0.04
Derivada_0.03 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.03)
Derivada_0.03
derivada3ptos_Progresiva_Endpoint<-function(x, y, xindice){
yprima[xindice] = (-3*y[xindice] + 4*y[xindice+1] - y[xindice+2])/(2*h)
return(yprima[xindice])
}
Derivada_0.04 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.04)
Derivada_0.04
Derivada_0.03 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.03)
Derivada_0.03
h = diff(x)[1]
derivada3ptos_Progresiva_Endpoint<-function(x, y, xindice){
h = diff(x)[1]
yprima[xindice] = (-3*y[xindice] + 4*y[xindice+1] - y[xindice+2])/(2*h)
return(yprima[xindice])
}
Derivada_0.04 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.04)
Derivada_0.04
Derivada_0.03 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.03)
Derivada_0.03
n = length(y)
yprima = c(rep(NA,n))
h = diff(x)[1]
yprima[xindice] = (-3*y[xindice] + 4*y[xindice+1] - y[xindice+2])/(2*h)
derivada3ptos_Progresiva_Endpoint<-function(x, y, xindice){
n = length(y)
yprima = c(rep(NA,n))
h = diff(x)[1]
yprima[xindice] = (-3*y[xindice] + 4*y[xindice+1] - y[xindice+2])/(2*h)
return(yprima[xindice])
}
Derivada_0.04 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.04)
Derivada_0.04
Derivada_0.03 = derivada3ptos_Progresiva_Endpoint(r,Pr,0.03)
Derivada_0.03
df <- data.frame(r,Pr)
#### EJERCICIO 2 #####
r <- seq(0,0.12, by=0.01)
Pr <- c(115.3371, 109.7031,104.8099,100.0653,95.3516,91.1998,87.2676,83.5825,79.9116,76.8435,73.9473,70.0320,67.7022)
df <- data.frame(r,Pr)
derivada3ptos_Progresiva_Endpoint<-<- function(fx, h) {
return((1/(2*h))*(-3*fx[1]+4*fx[2]-fx[3]))
}
derivada3ptos_Progresiva_Endpoint<-<- function(fx, h) {
return((1/(2*h))*(-3*fx[1]+4*fx[2]-fx[3]))
}
derivada3ptos_Progresiva_Endpoint<- function(fx, h) {
return((1/(2*h))*(-3*fx[1]+4*fx[2]-fx[3]))
}
# 2.1 Derivada Primera ----
Derivada_0.03 = derivada3ptos_Progresiva_Endpoint(fx = c(100.0653, 95.3516, 91.1998), h = 0.01)
Derivada_0.03
Derivada_0.04 = derivada3ptos_Progresiva_Endpoint(fx = c(95.3516,91.1998,87.4676),0.01)
Derivada_0.04
#2.2 Derivada Segunda
derivada_segunda = function(x, y, xindice){
h = diff(x)[1]
n = length(y)
yprima = c(rep(NA,n))
if(missing(xindice)){
for (i in 2:(n - 1)) {
yprima[i] = (y[i-1] - 2*y[i] + y[i+1])/(h^2)
}
tabla = cbind.data.frame(x, y, yprima)
return(tabla)
}
else{
if(xindice == 1 || xindice == n){
return("Este valor no se puede calcular")
}
else{
yprima[xindice] = (y[xindice-1] - 2*y[xindice] + y[xindice+1])/(h^2)
return(yprima[xindice])
}
}
}
#2.2 Derivada Segunda
derivada_segunda = function(x, y, xindice){
h = diff(x)[1]
n = length(y)
yprima = c(rep(NA,n))
if(missing(xindice)){
for (i in 2:(n - 1)) {
yprima[i] = (y[i-1] - 2*y[i] + y[i+1])/(h^2)
}
tabla = cbind.data.frame(x, y, yprima)
return(tabla)
}
else{
if(xindice == 1 || xindice == n){
return("Este valor no se puede calcular")
}
else{
yprima[xindice] = (y[xindice-1] - 2*y[xindice] + y[xindice+1])/(h^2)
return(yprima[xindice])
}
}
}
Derivada_Segunda_0.03 = derivada_segunda(r,Pr,0.03)
Derivada_Segunda_0.03
Derivada_Segunda_0.04 = derivada_segunda(r,Pr,0.04)
Derivada_Segunda_0.04
#### EJERCICIO 2 #####
r <- seq(0,0.12, by=0.01)
Pr <- c(115.3371, 109.7031,104.8099,100.0653,95.3516,91.1998,87.2676,83.5825,79.9116,76.8435,73.9473,70.0320,67.7022)
Derivada_Segunda_0.03 = derivada_segunda(r,Pr,0.03)
Derivada_Segunda_0.03
